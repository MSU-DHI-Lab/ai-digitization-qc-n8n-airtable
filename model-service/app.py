import logging
import os
import io
import time
from typing import List, Optional

from fastapi import FastAPI, File, UploadFile, HTTPException, Request
from fastapi.responses import JSONResponse
from pydantic import BaseModel
from PIL import Image, UnidentifiedImageError
import uvicorn

# --- Logging Setup ---
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
)
logger = logging.getLogger(__name__)

app = FastAPI(
    title="Digitization QC Model API",
    description="AI-powered quality control for collections scans.",
    version="0.2.0",
)

# --- Configuration helpers ---

def _get_bool_env(name: str, default: bool) -> bool:
    value = os.getenv(name)
    if value is None:
        return default
    return value.lower() == "true"

def _get_float_env(name: str, default: float) -> float:
    raw = os.getenv(name)
    if raw is None:
        return default
    try:
        return float(raw)
    except (TypeError, ValueError):
        logger.warning("Invalid value for %s (%s); falling back to %s", name, raw, default)
        return default

def _get_int_env(name: str, default: int) -> int:
    raw = os.getenv(name)
    if raw is None:
        return default
    try:
        return int(raw)
    except (TypeError, ValueError):
        logger.warning("Invalid value for %s (%s); falling back to %s", name, raw, default)
        return default

# --- Configuration ---
MODEL_API_TOKEN = os.getenv("MODEL_API_TOKEN")
ALLOW_NO_TOKEN = _get_bool_env("ALLOW_NO_TOKEN", False)
MAX_UPLOAD_MB = _get_float_env("MAX_UPLOAD_MB", 10)
MAX_PIXELS = _get_int_env("MAX_PIXELS", 35_000_000)  # ~7K x 5K
ALLOWED_MIME_TYPES = {"image/jpeg", "image/png", "image/tiff"}
ALLOWED_PIL_FORMATS = {"JPEG", "PNG", "TIFF"}
Image.MAX_IMAGE_PIXELS = MAX_PIXELS  # guard against decompression bombs

# --- Constants ---
HIGH_QUALITY_PIXEL_THRESHOLD = 2000 * 3000
SKEW_THRESHOLD_DEGREES = 2.0

if not MODEL_API_TOKEN and not ALLOW_NO_TOKEN:
    raise RuntimeError(
        "MODEL_API_TOKEN is required. Set it in your environment or set ALLOW_NO_TOKEN=true for local-only testing."
    )
if ALLOW_NO_TOKEN:
    logger.warning("ALLOW_NO_TOKEN is enabled; API requests are unauthenticated. Disable in production.")

# --- Pydantic Models for Data Contract ---

class Defects(BaseModel):
    finger_in_frame: bool
    skew_degrees: float
    blur: str  # "none", "mild", "strong"
    glare: bool
    cutoff_edges: bool

class QualityResponse(BaseModel):
    quality: str  # "high", "low"
    score: int    # 0-100
    defects: Defects
    reasons: List[str]
    # New Airtable Features
    rich_text_report: str
    semantic_tags: List[str]
    processed_at: str

# --- Core Logic ---

def generate_rich_text_report(quality: str, score: int, defects: Defects, reasons: List[str]) -> str:
    """Generates a Markdown report for Airtable Rich Text field."""
    icon = "âœ…" if quality == "high" else "âŒ"
    report = f"## {icon} AI Analysis: {quality.upper()} Confidence ({score}/100)\n\n"
    
    if quality == "high":
        report += "**Verdict**: This scan meets digitization standards.\n"
    else:
        report += "**Verdict**: Issues detected. Please review.\n"
        
    report += "\n### Detected Issues:\n"
    has_issues = False
    if defects.finger_in_frame:
        report += "- ðŸ‘† **Finger detected** in frame\n"
        has_issues = True
    if defects.skew_degrees > SKEW_THRESHOLD_DEGREES:
        report += f"- ðŸ“ **Skew**: {defects.skew_degrees}Â° (Threshold: {SKEW_THRESHOLD_DEGREES}Â°)\n"
        has_issues = True
    if defects.blur != "none":
        report += f"- ðŸŒ«ï¸ **Blur**: {defects.blur.capitalize()}\n"
        has_issues = True
    if defects.glare:
        report += "- ðŸ’¡ **Glare** detected\n"
        has_issues = True
    if defects.cutoff_edges:
        report += "- âœ‚ï¸ **Cutoff edges** detected\n"
        has_issues = True
        
    if not has_issues:
        report += "- *None detected*\n"
        
    report += "\n---\n*Generated by AI Model Service*"
    return report

def dummy_quality_score(img: Image.Image) -> QualityResponse:
    """
    Placeholder logic.
    In a real deployment, replace this with a trained model.
    
    Example integration:
    1. Load your ONNX model:
       session = onnxruntime.InferenceSession("model.onnx")
    2. Preprocess the image (resize, normalize).
    3. Run inference:
       inputs = {session.get_inputs()[0].name: preprocessed_img}
       outputs = session.run(None, inputs)
    4. Map outputs to QualityResponse.
    """
    width, height = img.size
    pixels = width * height
    logger.info(f"Processing image: {width}x{height} pixels")

    # Default to "high quality" values
    is_high_quality = (pixels >= HIGH_QUALITY_PIXEL_THRESHOLD)
    
    if is_high_quality:
        defects = Defects(
            finger_in_frame=False,
            skew_degrees=1.5,
            blur="none",
            glare=False,
            cutoff_edges=False,
        )
        reasons = ["Large image with sufficient resolution."]
        semantic_tags = ["High Res", "Clean Scan", "Standard"]
        score = 92
        quality = "high"
    else:
        defects = Defects(
            finger_in_frame=False,
            skew_degrees=6.0,
            blur="mild",
            glare=False,
            cutoff_edges=True,
        )
        reasons = ["Image appears small or cropped."]
        semantic_tags = ["Low Res", "Needs Review", "Cropped"]
        score = 55
        quality = "low"

    rich_text = generate_rich_text_report(quality, score, defects, reasons)

    return QualityResponse(
        quality=quality,
        score=score,
        defects=defects,
        reasons=reasons,
        rich_text_report=rich_text,
        semantic_tags=semantic_tags,
        processed_at=time.strftime("%Y-%m-%dT%H:%M:%S")
    )

# --- Validation helpers ---

def _enforce_size_limit(upload_file: UploadFile) -> None:
    try:
        upload_file.file.seek(0, 2)
        size_bytes = upload_file.file.tell()
        upload_file.file.seek(0)
    except Exception as exc:
        logger.warning("Unable to determine upload size: %s", exc)
        raise HTTPException(status_code=400, detail="Could not read upload size")

    size_mb = size_bytes / (1024 * 1024)
    if size_mb > MAX_UPLOAD_MB:
        logger.warning("Upload too large: %.2f MB (limit %.2f MB)", size_mb, MAX_UPLOAD_MB)
        raise HTTPException(status_code=413, detail=f"File exceeds max size of {MAX_UPLOAD_MB} MB")


def _open_image(upload_file: UploadFile) -> Image.Image:
    """Open and validate the uploaded image; ensures MIME matches detected format."""
    if upload_file.content_type not in ALLOWED_MIME_TYPES:
        logger.warning("Invalid content type: %s", upload_file.content_type)
        raise HTTPException(
            status_code=400,
            detail=f"File must be one of: {', '.join(sorted(ALLOWED_MIME_TYPES))}"
        )

    try:
        upload_file.file.seek(0)
        with Image.open(upload_file.file) as opened_img:
            opened_img.verify()
    except Image.DecompressionBombError as exc:
        logger.warning("Image exceeds pixel safety limit during verify: %s", exc)
        raise HTTPException(
            status_code=413,
            detail=f"Image dimensions exceed allowed limit ({MAX_PIXELS} pixels)",
        )
    except UnidentifiedImageError as exc:
        logger.warning("Image verification failed: %s", exc)
        raise HTTPException(status_code=400, detail="Invalid image file")
    except Exception as exc:
        logger.warning("Image verification error: %s", exc)
        raise HTTPException(status_code=400, detail="Invalid image file")

    try:
        upload_file.file.seek(0)
        with Image.open(upload_file.file) as opened_img:
            detected_format: Optional[str] = opened_img.format
            detected_mime = Image.MIME.get(detected_format or "")
            if detected_format not in ALLOWED_PIL_FORMATS or detected_mime not in ALLOWED_MIME_TYPES:
                logger.warning(
                    "Unsupported image format detected: %s (mime: %s)", detected_format, detected_mime
                )
                raise HTTPException(
                    status_code=400,
                    detail="Image format is not supported or does not match allowed types",
                )

            if detected_mime and upload_file.content_type and detected_mime != upload_file.content_type:
                logger.warning(
                    "Content-type mismatch: declared %s, detected %s",
                    upload_file.content_type,
                    detected_mime,
                )
                raise HTTPException(
                    status_code=400,
                    detail="Image content type does not match the actual file format",
                )

            img = opened_img.convert("RGB")
    except HTTPException:
        raise
    except Image.DecompressionBombError as exc:
        logger.warning("Image exceeds pixel safety limit during open: %s", exc)
        raise HTTPException(
            status_code=413,
            detail=f"Image dimensions exceed allowed limit ({MAX_PIXELS} pixels)",
        )
    except UnidentifiedImageError:
        logger.warning("Could not identify image during open")
        raise HTTPException(status_code=400, detail="Invalid image file")
    except Exception as exc:
        logger.warning("Error opening image: %s", exc)
        raise HTTPException(status_code=400, detail="Invalid image file")

    return img

# --- API Endpoints ---

@app.get("/health")
async def health_check():
    """Health check endpoint for n8n or container orchestrators."""
    return {"status": "healthy", "service": "model-service"}

@app.post("/predict", response_model=QualityResponse)
async def predict(request: Request, file: UploadFile = File(...)):
    logger.info(f"Received prediction request for file: {file.filename}")

    # Optional token-based auth (simple shared secret)
    if MODEL_API_TOKEN:
        supplied = request.headers.get("x-api-token")
        if supplied != MODEL_API_TOKEN:
            logger.warning("Unauthorized request")
            raise HTTPException(status_code=401, detail="Unauthorized")

    try:
        _enforce_size_limit(file)
        img = _open_image(file)
    except HTTPException:
        raise
    except Exception as exc:
        logger.exception("Unexpected error during image handling: %s", exc)
        raise HTTPException(status_code=500, detail="Internal processing error")

    width, height = img.size
    if width * height > MAX_PIXELS:
        logger.warning(f"Image too large: {width}x{height}")
        raise HTTPException(status_code=413, detail=f"Image dimensions exceed allowed limit ({MAX_PIXELS} pixels)")

    try:
        result = dummy_quality_score(img)
    except Exception as exc:
        logger.exception("Error generating prediction: %s", exc)
        raise HTTPException(status_code=500, detail="Internal processing error")
    logger.info(f"Prediction complete. Quality: {result.quality}, Score: {result.score}")
    return result

if __name__ == "__main__":
    uvicorn.run("app:app", host="0.0.0.0", port=8000)
